#include<iostream>
#include<iomanip> 
#include<cstring>
#include<cmath>
#include<assert.h>
using namespace std;
class stack {
public:
	stack();
	~stack();
	void push(int x);
	bool empty() const;
	void pop();
	int top() const;
	stack(const stack&);
	stack(stack&&) noexcept;
	stack& operator = (const stack& rhs);
	stack& operator = (stack&&) noexcept;
private:
	struct Node
	{
		int data;
		Node* next;
	}*m_head;//=nullptr;
};
stack::stack()
{
	m_head = nullptr;
}
stack::~stack()
{
	while (m_head)
	{
		Node* p = m_head;
		m_head = p->next;
		delete p;
	}
}
void stack::push(int x)
{
	Node* p = new Node;
	p->data = x;
	p->next = m_head;
	m_head = p;
}
bool stack::empty()const
{
	return(m_head == nullptr);
}
int stack::top()const
{
	return m_head->data;
}
void stack::pop()
{
	Node* p = m_head;
	m_head = p->next;
	delete p;
}
stack::stack(const stack& rhs)
{
	m_head = new Node;
	m_head->data = rhs.m_head->data;
	m_head->next = rhs.m_head->next;
	Node* last = m_head;
	Node* p = rhs.m_head->next;
	while (p)
	{
		Node* q = new Node;
		q->data = p->data;
		q->next = p->next;
		last->next = q;
		last = q;
		p = p->next;
	}
	last->next = NULL;
}
stack::stack(stack&& rhs) noexcept
{
	m_head = rhs.m_head;
	rhs.m_head = NULL;
}
stack& stack::operator=(const stack& rhs)
{
	stack tmp(rhs);
	Node* t = m_head;
	m_head = tmp.m_head;
	tmp.m_head = t;
	return *this;
}
stack& stack::operator=(stack&& rhs) noexcept
{
	Node* p = this->m_head;
	this->m_head = rhs.m_head;
	rhs.m_head = p;
	return *this;
}
int main()
{
	stack A,B;
	int i, m, x, y, n;
	cin >> m;
	for (i = 0; i < m; i++)
	{
		cin >> x;
		A.push(x);
	}
	//B=move(A);
	B = A;
	while (!A.empty())
	{
		n = A.top();
		cout << n << " ";
		A.pop();
	}
	cout << endl;
	while (!B.empty())
	{
		y = B.top();
		cout << y << " ";
		B.pop();
	}
	cout << endl;
	system("pause");
}
